// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";

import "./IInterfaces.sol";
import "./BKCToken.sol";

/**
 * @title DelegationManager
 * @notice Manages staking, locking rules, and rewards within the Backcoin Protocol.
 * @dev 
 * - Implements "Saved Rewards" logic and global Booster discounts.
 * - Stakers earn yield generated by protocol fees (MiningManager).
 * - Fees and penalties trigger "Proof-of-Purchase" mining.
 * Part of the Backcoin Ecosystem.
 * Website: Backcoin.org
 * Optimized for Arbitrum Network.
 */
contract DelegationManager is
    Initializable,
    UUPSUpgradeable,
    OwnableUpgradeable,
    ReentrancyGuardUpgradeable,
    IDelegationManager
{
    using SafeERC20Upgradeable for BKCToken;

    // --- State Variables ---

    IEcosystemManager public ecosystemManager;
    BKCToken public bkcToken;

    uint256 public constant MIN_LOCK_DURATION = 1 days;
    uint256 public constant MAX_LOCK_DURATION = 3650 days;
    uint256 private constant E18 = 10**18;

    // Fee Keys
    bytes32 public constant DELEGATION_FEE_KEY = keccak256("DELEGATION_FEE_BIPS");
    bytes32 public constant UNSTAKE_FEE_KEY = keccak256("UNSTAKE_FEE_BIPS");
    bytes32 public constant FORCE_UNSTAKE_PENALTY_KEY = keccak256("FORCE_UNSTAKE_PENALTY_BIPS");
    bytes32 public constant CLAIM_REWARD_FEE_KEY = keccak256("CLAIM_REWARD_FEE_BIPS");

    struct Delegation {
        uint256 amount;
        uint64 unlockTime;
        uint64 lockDuration;
    }

    mapping(address => Delegation[]) public userDelegations;
    mapping(address => uint256) public userTotalPStake;
    mapping(address => uint256) public rewardDebt;
    // Stores rewards that have been calculated but not yet claimed to wallet
    mapping(address => uint256) public savedRewards;

    uint256 public totalNetworkPStake;
    uint256 public accRewardPerStake; 

    // --- Events ---

    // CORREÇÃO: O evento Delegated já é herdado de IDelegationManager. Não redeclarar.
    
    event Unstaked(address indexed user, uint256 delegationIndex, uint256 amount, uint256 feePaid);
    event RewardsDeposited(uint256 amount);
    event RewardClaimed(address indexed user, uint256 amount);

    // --- Errors ---

    error InvalidAddress();
    error InvalidAmount();
    error InvalidDuration();
    error InvalidIndex();
    error Unauthorized();
    error LockPeriodNotOver();
    error DelegationUnlocked();
    error TokenNotSet();

    // --- Initialization ---

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(
        address _initialOwner,
        address _ecosystemManagerAddress
    ) public initializer {
        if (_initialOwner == address(0)) revert InvalidAddress();
        if (_ecosystemManagerAddress == address(0)) revert InvalidAddress();

        __Ownable_init();
        _transferOwnership(_initialOwner);
        __UUPSUpgradeable_init();
        __ReentrancyGuard_init();
        
        ecosystemManager = IEcosystemManager(_ecosystemManagerAddress);
        address _bkcTokenAddress = ecosystemManager.getBKCTokenAddress();
        if (_bkcTokenAddress == address(0)) revert TokenNotSet();
        
        bkcToken = BKCToken(_bkcTokenAddress);
    }

    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}

    // --- Core Logic ---

    /**
     * @notice Distributes rewards to the pool.
     * @dev Usually called by MiningManager or Treasury.
     */
    function depositMiningRewards(uint256 _amount) external override { 
        if (msg.sender != ecosystemManager.getMiningManagerAddress()) revert Unauthorized();
        if (_amount > 0 && totalNetworkPStake > 0) {
            accRewardPerStake += (_amount * E18) / totalNetworkPStake;
            emit RewardsDeposited(_amount);
        }
    }

    /**
     * @notice DELEGATE (Stake/Lock Tokens)
     * @dev Applies Booster discount on Entry Fee (if any).
     */
    function delegate(
        uint256 _totalAmount, 
        uint256 _lockDuration,
        uint256 _boosterTokenId 
    ) external nonReentrant {
        if (_totalAmount == 0) revert InvalidAmount();
        if (_lockDuration < MIN_LOCK_DURATION || _lockDuration > MAX_LOCK_DURATION) revert InvalidDuration();

        // 1. Update accumulated rewards before changing stake
        _updateUserData(msg.sender);

        // 2. Calculate Fee with Booster Discount
        uint256 baseFeeBips = ecosystemManager.getFee(DELEGATION_FEE_KEY);
        uint256 finalFeeBips = _applyBoosterDiscount(baseFeeBips, _boosterTokenId);
        
        uint256 feeAmount = 0;
        uint256 netAmount = _totalAmount;

        if (finalFeeBips > 0) {
            feeAmount = (_totalAmount * finalFeeBips) / 10000;
            netAmount = _totalAmount - feeAmount;
            if (netAmount == 0) revert InvalidAmount();
        }

        // 3. Transfer tokens from user to contract
        bkcToken.safeTransferFrom(msg.sender, address(this), _totalAmount);

        // 4. Send fee to Mining/Treasury
        if (feeAmount > 0) {
            _sendFeeToMiningManager(DELEGATION_FEE_KEY, feeAmount);
        }

        // 5. Register Delegation
        uint256 delegationIndex = userDelegations[msg.sender].length;
        userDelegations[msg.sender].push(Delegation({
            amount: netAmount,
            unlockTime: uint64(block.timestamp + _lockDuration),
            lockDuration: uint64(_lockDuration)
        }));

        // 6. Calculate pStake (Weight)
        uint256 pStake = _calculatePStake(netAmount, _lockDuration);

        // 7. Update Global State
        totalNetworkPStake += pStake;
        userTotalPStake[msg.sender] += pStake;

        // 8. Reset Reward Debt
        rewardDebt[msg.sender] = (userTotalPStake[msg.sender] * accRewardPerStake) / E18;

        emit Delegated(msg.sender, delegationIndex, netAmount, pStake, feeAmount);
    }

    /**
     * @notice UNSTAKE (Withdraw Principal after lock expires)
     * @dev Applies Booster discount on Unstake Fee.
     */
    function unstake(
        uint256 _delegationIndex, 
        uint256 _boosterTokenId 
    ) external nonReentrant {
        Delegation[] storage delegationsOfUser = userDelegations[msg.sender];
        if (_delegationIndex >= delegationsOfUser.length) revert InvalidIndex();
        
        Delegation storage d = delegationsOfUser[_delegationIndex];

        // 1. Update Rewards
        _updateUserData(msg.sender);

        if (block.timestamp < d.unlockTime) revert LockPeriodNotOver();

        uint256 amount = d.amount;
        uint256 pStakeToRemove = _calculatePStake(amount, d.lockDuration);

        // 2. Calculate Unstake Fee with Booster Discount
        uint256 baseFeeBips = ecosystemManager.getFee(UNSTAKE_FEE_KEY);
        uint256 finalFeeBips = _applyBoosterDiscount(baseFeeBips, _boosterTokenId);

        uint256 feeAmount = (amount * finalFeeBips) / 10000;
        uint256 amountToUser = amount - feeAmount;

        // 3. Update State
        totalNetworkPStake -= pStakeToRemove;
        userTotalPStake[msg.sender] -= pStakeToRemove;

        if (feeAmount > 0) {
            _sendFeeToMiningManager(UNSTAKE_FEE_KEY, feeAmount);
        }

        // 4. Remove Delegation (Swap and Pop)
        uint256 lastIndex = delegationsOfUser.length - 1;
        if (_delegationIndex != lastIndex) {
            delegationsOfUser[_delegationIndex] = delegationsOfUser[lastIndex];
        }
        delegationsOfUser.pop();

        // 5. Transfer Principal
        bkcToken.safeTransfer(msg.sender, amountToUser);

        // 6. Update Debt
        rewardDebt[msg.sender] = (userTotalPStake[msg.sender] * accRewardPerStake) / E18;

        emit Unstaked(msg.sender, _delegationIndex, amountToUser, feeAmount);
    }

    /**
     * @notice FORCE UNSTAKE (Early withdrawal with Penalty)
     * @dev Applies Booster discount on the Penalty (Tiered Discount).
     */
    function forceUnstake(
        uint256 _delegationIndex, 
        uint256 _boosterTokenId
    ) external nonReentrant {
        Delegation[] storage delegationsOfUser = userDelegations[msg.sender];
        if (_delegationIndex >= delegationsOfUser.length) revert InvalidIndex();
        
        Delegation storage d = delegationsOfUser[_delegationIndex];

        // 1. Update Rewards
        _updateUserData(msg.sender);

        if (block.timestamp >= d.unlockTime) revert DelegationUnlocked();

        uint256 amount = d.amount;
        uint256 pStakeToRemove = _calculatePStake(amount, d.lockDuration);

        // 2. Calculate Penalty with Booster Discount
        uint256 basePenaltyBips = ecosystemManager.getFee(FORCE_UNSTAKE_PENALTY_KEY);
        uint256 finalPenaltyBips = _applyBoosterDiscount(basePenaltyBips, _boosterTokenId);

        uint256 penaltyAmount = (amount * finalPenaltyBips) / 10000;
        uint256 amountToUser = amount - penaltyAmount;

        // 3. Update State
        totalNetworkPStake -= pStakeToRemove;
        userTotalPStake[msg.sender] -= pStakeToRemove;

        if (penaltyAmount > 0) {
            _sendFeeToMiningManager(FORCE_UNSTAKE_PENALTY_KEY, penaltyAmount);
        }
        
        // 4. Remove Delegation
        uint256 lastIndex = delegationsOfUser.length - 1;
        if (_delegationIndex != lastIndex) {
            delegationsOfUser[_delegationIndex] = delegationsOfUser[lastIndex];
        }
        delegationsOfUser.pop();
        
        // 5. Transfer Remaining Principal
        bkcToken.safeTransfer(msg.sender, amountToUser);

        // 6. Update Debt
        rewardDebt[msg.sender] = (userTotalPStake[msg.sender] * accRewardPerStake) / E18;

        emit Unstaked(msg.sender, _delegationIndex, amountToUser, penaltyAmount);
    }

    /**
     * @notice CLAIM REWARD (Withdraw accumulated profits)
     * @dev Applies Booster discount on Claim Fee.
     */
    function claimReward(uint256 _boosterTokenId) external nonReentrant {
        // 1. Update recent rewards
        _updateUserData(msg.sender);

        // 2. Check savings
        uint256 totalToClaim = savedRewards[msg.sender];
        if (totalToClaim > 0) {
            // Reset savings (Reentrancy protection)
            savedRewards[msg.sender] = 0;
            rewardDebt[msg.sender] = (userTotalPStake[msg.sender] * accRewardPerStake) / E18;

            // 3. Calculate Fee with Booster Discount
            uint256 baseFeeBips = ecosystemManager.getFee(CLAIM_REWARD_FEE_KEY);
            uint256 finalFeeBips = _applyBoosterDiscount(baseFeeBips, _boosterTokenId);
            
            uint256 feeAmount = (totalToClaim * finalFeeBips) / 10000;
            uint256 amountToUser = totalToClaim - feeAmount;

            // 4. Distribute
            if (feeAmount > 0) {
                _sendFeeToMiningManager(CLAIM_REWARD_FEE_KEY, feeAmount);
            }

            if (amountToUser > 0) {
                bkcToken.safeTransfer(msg.sender, amountToUser);
            }

            emit RewardClaimed(msg.sender, amountToUser);
        }
    }

    // --- Internal Helpers ---

    function _updateUserData(address _user) internal {
        if (userTotalPStake[_user] > 0) {
            uint256 pending = (userTotalPStake[_user] * accRewardPerStake / E18) - rewardDebt[_user];
            if (pending > 0) {
                savedRewards[_user] += pending;
            }
        }
    }

    function _sendFeeToMiningManager(bytes32 _serviceKey, uint256 _feeAmount) internal {
        address miningManagerAddress = ecosystemManager.getMiningManagerAddress();
        if (miningManagerAddress == address(0)) revert InvalidAddress();
        
        bkcToken.safeTransfer(miningManagerAddress, _feeAmount);
        
        // Notify MiningManager to process the fee (e.g. split between treasury/burn/pool)
        IMiningManager(miningManagerAddress).performPurchaseMining(
            _serviceKey,
            _feeAmount
        );
    }

    /**
     * @dev Checks with EcosystemManager/BoosterNFT to calculate the reduced fee.
     */
    function _applyBoosterDiscount(uint256 _baseFeeBips, uint256 _boosterTokenId) internal view returns (uint256 finalFeeBips) {
        // If no fee, no discount needed
        if (_baseFeeBips == 0) return 0;
        // If no booster provided, return base fee
        if (_boosterTokenId == 0) return _baseFeeBips;
        
        address boosterAddress = ecosystemManager.getBoosterAddress();
        if (boosterAddress == address(0)) return _baseFeeBips;
        
        IRewardBoosterNFT booster = IRewardBoosterNFT(boosterAddress);
        
        // Try/Catch prevents invalid NFT calls from reverting the main transaction
        try booster.ownerOf(_boosterTokenId) returns (address owner) {
            // Only apply discount if the sender actually owns the NFT
            if (owner == msg.sender) {
                uint256 boostBips = booster.boostBips(_boosterTokenId);
                uint256 discountBips = ecosystemManager.getBoosterDiscount(boostBips);
                
                if (discountBips > 0) {
                    return (_baseFeeBips > discountBips) ? (_baseFeeBips - discountBips) : 0;
                }
            }
        } catch { }
        return _baseFeeBips;
    }

    function _calculatePStake(uint256 _amount, uint256 _lockDuration) internal pure returns (uint256) {
        return (_amount * (_lockDuration / 1 days)) / E18;
    }

    // --- View Functions ---

    function pendingRewards(address _user) public view returns (uint256) {
        uint256 currentPending = 0;
        if (userTotalPStake[_user] > 0) {
            currentPending = (userTotalPStake[_user] * accRewardPerStake / E18) - rewardDebt[_user];
        }
        return currentPending + savedRewards[_user];
    }

    function getDelegationsOf(address _user) external view returns (Delegation[] memory) {
        return userDelegations[_user];
    }
}