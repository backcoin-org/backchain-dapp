// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ” BACKCOIN ECOSYSTEM - DIAGNÃ“STICO COMPLETO V3.0
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Cole este script inteiro no Console do Navegador (F12) e pressione Enter
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(async function runFullDiagnostic() {
    console.clear();
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    console.log("ğŸ” BACKCOIN ECOSYSTEM - DIAGNÃ“STICO COMPLETO V3.0");
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    console.log("â³ Iniciando anÃ¡lise de todos os contratos...\n");

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ENDEREÃ‡OS DOS CONTRATOS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const ADDRESSES = {
        ecosystemManager: "0xA2D6D804ec837D8D45C0e5eef3D35B1F1D92a54D",
        bkcToken: "0x770267659c3708dBcAC2010d30235875193E900A",
        rewardBoosterNFT: "0xd51D6b0f689A69B08d011E1063488a0eD2ee5580",
        miningManager: "0xa871a70cCA6D17AB5b13980e95f67969BC19A39e",
        delegationManager: "0x8E23BfB9CB032042fe6e5B075b55056814D02B20",
        decentralizedNotary: "0xc1EfCd250d27db3D1FC6484D6271F90A43d8ae14",
        fortunePool: "0xD36fdB64B59F5528cdBDd1b770Fe003580b6cd74",
        rentalManager: "0x17F7851f6658e5ed716e10b505484Afd7285901e",
        nftLiquidityPool_Implementation: "0xe7B60Db9D7F92F72E6C20a81BAAD95e218cBa2dd",
        nftLiquidityPoolFactory: "0xaEadaA02158dc7A1531329c2105707dA1F37CCf8",
        publicSale: "0xD4F47596B83b6AF2e05AAb4A4e7c8D25886F7651",
        faucet: "0x4483EFf66264b085ed3Cbc699ed6924caaBDE07D",
        pool_diamond: "0x15dEbE828954c232E923520108f0D617dfA177EB",
        pool_platinum: "0x02858C4e7bE22DA8808c546992c47E0d456161Cc",
        pool_gold: "0x822cbaAd458B111432ffB73C64822ad43917a529",
        pool_silver: "0x0FB31cD02FaC64Ea885F2D5208E63d44DF03Ac61",
        pool_bronze: "0xfaB93a91ef97C93c24694f7fecBcA929ce91F567",
        pool_iron: "0xFC78A8133f15b8F3d9Fd4C8401dec6294AdE2CfE",
        pool_crystal: "0x9852F72b4EBf34db773B43C9a0d3616Df8644055"
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ABIs NECESSÃRIAS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const ABIS = {
        ownable: ["function owner() view returns (address)"],
        
        bkcToken: [
            "function owner() view returns (address)",
            "function totalSupply() view returns (uint256)",
            "function MAX_SUPPLY() view returns (uint256)",
            "function balanceOf(address) view returns (uint256)",
            "function isMinter(address) view returns (bool)"
        ],
        
        ecosystemManager: [
            "function owner() view returns (address)",
            "function getBKCTokenAddress() view returns (address)",
            "function getMiningManagerAddress() view returns (address)",
            "function getDelegationManagerAddress() view returns (address)",
            "function getTreasuryAddress() view returns (address)",
            "function getBoosterAddress() view returns (address)",
            "function getDecentralizedNotaryAddress() view returns (address)",
            "function getFortunePoolAddress() view returns (address)",
            "function getNFTLiquidityPoolFactoryAddress() view returns (address)",
            "function getMiningDistributionBips(bytes32) view returns (uint256)",
            "function getFeeDistributionBips(bytes32) view returns (uint256)",
            "function getFee(bytes32) view returns (uint256)",
            "function getBoosterDiscount(uint256) view returns (uint256)"
        ],
        
        miningManager: [
            "function owner() view returns (address)",
            "function ecosystemManager() view returns (address)",
            "function bkcTokenAddress() view returns (address)",
            "function authorizedMiners(bytes32) view returns (address)",
            "function getMintAmount(uint256) view returns (uint256)"
        ],
        
        delegationManager: [
            "function owner() view returns (address)",
            "function ecosystemManager() view returns (address)",
            "function totalNetworkPStake() view returns (uint256)",
            "function accRewardPerStake() view returns (uint256)",
            "function userTotalPStake(address) view returns (uint256)",
            "function pendingRewards(address) view returns (uint256)",
            "function getDelegationsOf(address) view returns (tuple(uint256 amount, uint64 unlockTime, uint64 lockDuration)[])"
        ],
        
        rentalManager: [
            "function owner() view returns (address)",
            "function ecosystemManager() view returns (address)",
            "function bkcToken() view returns (address)",
            "function nftContract() view returns (address)",
            "function getAllListedTokenIds() view returns (uint256[])",
            "function getListing(uint256) view returns (tuple(address owner, uint256 price, bool isActive))",
            "function isRented(uint256) view returns (bool)"
        ],
        
        nftPool: [
            "function owner() view returns (address)",
            "function ecosystemManager() view returns (address)",
            "function boostBips() view returns (uint256)",
            "function getBuyPrice() view returns (uint256)",
            "function getSellPrice() view returns (uint256)",
            "function getPoolInfo() view returns (uint256 tokenBalance, uint256 nftCount, uint256 k)",
            "function getAvailableTokenIds() view returns (uint256[])"
        ],
        
        nftFactory: [
            "function owner() view returns (address)",
            "function ecosystemManagerAddress() view returns (address)",
            "function poolImplementation() view returns (address)",
            "function isPool(address) view returns (bool)",
            "function getPoolAddress(uint256) view returns (address)",
            "function getDeployedBoostBips() view returns (uint256[])"
        ],
        
        rewardBoosterNFT: [
            "function owner() view returns (address)",
            "function totalSupply() view returns (uint256)",
            "function balanceOf(address) view returns (uint256)",
            "function boostBips(uint256) view returns (uint256)",
            "function ownerOf(uint256) view returns (address)"
        ],
        
        notary: [
            "function owner() view returns (address)",
            "function ecosystemManager() view returns (address)",
            "function totalSupply() view returns (uint256)"
        ],
        
        fortunePool: [
            "function owner() view returns (address)",
            "function ecosystemManager() view returns (address)",
            "function bkcToken() view returns (address)"
        ],
        
        publicSale: [
            "function owner() view returns (address)",
            "function ecosystemManager() view returns (address)",
            "function rewardBoosterNFT() view returns (address)"
        ],
        
        faucet: [
            "function owner() view returns (address)",
            "function bkcToken() view returns (address)",
            "function claimAmount() view returns (uint256)",
            "function cooldownTime() view returns (uint256)"
        ]
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // RESULTADOS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const results = {
        critical: [],
        warnings: [],
        ok: [],
        info: []
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HELPERS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const provider = new ethers.BrowserProvider(window.ethereum);
    const signer = await provider.getSigner();
    const userAddress = await signer.getAddress();
    const network = await provider.getNetwork();
    
    console.log(`ğŸ“¡ Rede: ${network.name} (Chain ID: ${network.chainId})`);
    console.log(`ğŸ‘¤ UsuÃ¡rio: ${userAddress}\n`);

    const formatEther = (wei) => {
        try {
            return parseFloat(ethers.formatEther(wei)).toFixed(4);
        } catch {
            return "0";
        }
    };

    const safeCall = async (contract, method, args = [], fallback = null) => {
        try {
            return await contract[method](...args);
        } catch (e) {
            return fallback;
        }
    };

    const checkAddress = (addr, name) => {
        if (!addr || addr === ethers.ZeroAddress) {
            results.critical.push(`ğŸ”´ ${name}: NÃƒO CONFIGURADO (ZeroAddress)`);
            return false;
        }
        return true;
    };

    // Keys comuns
    const KEYS = {
        TREASURY: ethers.keccak256(ethers.toUtf8Bytes("TREASURY")),
        DELEGATOR_POOL: ethers.keccak256(ethers.toUtf8Bytes("DELEGATOR_POOL")),
        DELEGATION_FEE: ethers.keccak256(ethers.toUtf8Bytes("DELEGATION_FEE_BIPS")),
        UNSTAKE_FEE: ethers.keccak256(ethers.toUtf8Bytes("UNSTAKE_FEE_BIPS")),
        FORCE_UNSTAKE_PENALTY: ethers.keccak256(ethers.toUtf8Bytes("FORCE_UNSTAKE_PENALTY_BIPS")),
        CLAIM_REWARD_FEE: ethers.keccak256(ethers.toUtf8Bytes("CLAIM_REWARD_FEE_BIPS")),
        NFT_BUY_TAX: ethers.keccak256(ethers.toUtf8Bytes("NFT_POOL_BUY_TAX_BIPS")),
        NFT_SELL_TAX: ethers.keccak256(ethers.toUtf8Bytes("NFT_POOL_SELL_TAX_BIPS")),
        RENTAL_TAX: ethers.keccak256(ethers.toUtf8Bytes("RENTAL_MARKET_TAX_BIPS")),
        NOTARY_SERVICE: ethers.keccak256(ethers.toUtf8Bytes("NOTARY_SERVICE"))
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 1. BKC TOKEN
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    console.log("1ï¸âƒ£  BKC TOKEN");
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    
    try {
        const bkc = new ethers.Contract(ADDRESSES.bkcToken, ABIS.bkcToken, provider);
        
        const [owner, totalSupply, maxSupply, userBalance] = await Promise.all([
            safeCall(bkc, 'owner', [], ethers.ZeroAddress),
            safeCall(bkc, 'totalSupply', [], 0n),
            safeCall(bkc, 'MAX_SUPPLY', [], 0n),
            safeCall(bkc, 'balanceOf', [userAddress], 0n)
        ]);
        
        console.log(`   Owner: ${owner}`);
        console.log(`   Total Supply: ${formatEther(totalSupply)} BKC`);
        console.log(`   Max Supply: ${formatEther(maxSupply)} BKC`);
        console.log(`   Seu Balance: ${formatEther(userBalance)} BKC`);
        
        // Verifica se MiningManager Ã© owner
        if (owner.toLowerCase() === ADDRESSES.miningManager.toLowerCase()) {
            results.ok.push("âœ… BKCToken: Owner = MiningManager (pode mintar)");
        } else {
            results.critical.push(`ğŸ”´ BKCToken: Owner (${owner}) â‰  MiningManager!`);
        }
        
        // Tenta verificar Minter Role (V2)
        const isMinter = await safeCall(bkc, 'isMinter', [ADDRESSES.miningManager], null);
        if (isMinter === true) {
            results.ok.push("âœ… BKCToken V2: MiningManager tem Minter Role");
        } else if (isMinter === false) {
            results.warnings.push("âš ï¸ BKCToken V2: MiningManager NÃƒO tem Minter Role");
        } else {
            results.info.push("â„¹ï¸ BKCToken Ã© V1 (sem Minter Role)");
        }
        
    } catch (e) {
        results.critical.push(`ğŸ”´ BKCToken: Erro - ${e.message.slice(0, 50)}`);
    }
    console.log("");

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 2. ECOSYSTEM MANAGER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    console.log("2ï¸âƒ£  ECOSYSTEM MANAGER (HUB)");
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    
    try {
        const ecosystem = new ethers.Contract(ADDRESSES.ecosystemManager, ABIS.ecosystemManager, provider);
        
        const owner = await safeCall(ecosystem, 'owner', [], ethers.ZeroAddress);
        console.log(`   Owner: ${owner}`);
        
        // EndereÃ§os configurados
        console.log("\n   ğŸ“ EndereÃ§os Configurados:");
        const configuredAddrs = {
            BKCToken: await safeCall(ecosystem, 'getBKCTokenAddress', [], ethers.ZeroAddress),
            MiningManager: await safeCall(ecosystem, 'getMiningManagerAddress', [], ethers.ZeroAddress),
            DelegationManager: await safeCall(ecosystem, 'getDelegationManagerAddress', [], ethers.ZeroAddress),
            Treasury: await safeCall(ecosystem, 'getTreasuryAddress', [], ethers.ZeroAddress),
            Booster: await safeCall(ecosystem, 'getBoosterAddress', [], ethers.ZeroAddress),
            Notary: await safeCall(ecosystem, 'getDecentralizedNotaryAddress', [], ethers.ZeroAddress),
            FortunePool: await safeCall(ecosystem, 'getFortunePoolAddress', [], ethers.ZeroAddress),
            NFTFactory: await safeCall(ecosystem, 'getNFTLiquidityPoolFactoryAddress', [], ethers.ZeroAddress)
        };
        
        for (const [name, addr] of Object.entries(configuredAddrs)) {
            const status = addr === ethers.ZeroAddress ? "âŒ NÃƒO CONFIGURADO" : "âœ…";
            console.log(`      ${name}: ${addr} ${status === "âŒ NÃƒO CONFIGURADO" ? status : ""}`);
            
            if (addr === ethers.ZeroAddress) {
                results.critical.push(`ğŸ”´ EcosystemManager: ${name} nÃ£o configurado!`);
            }
        }
        
        // DistribuiÃ§Ãµes
        console.log("\n   ğŸ“Š DistribuiÃ§Ãµes:");
        const [miningTreasury, miningDelegator, feeTreasury, feeDelegator] = await Promise.all([
            safeCall(ecosystem, 'getMiningDistributionBips', [KEYS.TREASURY], 0n),
            safeCall(ecosystem, 'getMiningDistributionBips', [KEYS.DELEGATOR_POOL], 0n),
            safeCall(ecosystem, 'getFeeDistributionBips', [KEYS.TREASURY], 0n),
            safeCall(ecosystem, 'getFeeDistributionBips', [KEYS.DELEGATOR_POOL], 0n)
        ]);
        
        const miningTotal = BigInt(miningTreasury) + BigInt(miningDelegator);
        const feeTotal = BigInt(feeTreasury) + BigInt(feeDelegator);
        
        console.log(`      Mining: Treasury=${miningTreasury}, Delegator=${miningDelegator}, TOTAL=${miningTotal}`);
        console.log(`      Fee: Treasury=${feeTreasury}, Delegator=${feeDelegator}, TOTAL=${feeTotal}`);
        
        if (miningTotal !== 10000n) {
            results.critical.push(`ğŸ”´ Mining Distribution = ${miningTotal} (DEVE SER 10000!)`);
        } else {
            results.ok.push("âœ… Mining Distribution = 10000");
        }
        
        if (feeTotal !== 10000n) {
            results.critical.push(`ğŸ”´ Fee Distribution = ${feeTotal} (DEVE SER 10000!)`);
        } else {
            results.ok.push("âœ… Fee Distribution = 10000");
        }
        
        // Fees de serviÃ§os
        console.log("\n   ğŸ’° Fees de ServiÃ§os (BIPS):");
        const fees = {
            'DELEGATION_FEE': await safeCall(ecosystem, 'getFee', [KEYS.DELEGATION_FEE], 0n),
            'UNSTAKE_FEE': await safeCall(ecosystem, 'getFee', [KEYS.UNSTAKE_FEE], 0n),
            'FORCE_UNSTAKE_PENALTY': await safeCall(ecosystem, 'getFee', [KEYS.FORCE_UNSTAKE_PENALTY], 0n),
            'CLAIM_REWARD_FEE': await safeCall(ecosystem, 'getFee', [KEYS.CLAIM_REWARD_FEE], 0n),
            'NFT_BUY_TAX': await safeCall(ecosystem, 'getFee', [KEYS.NFT_BUY_TAX], 0n),
            'NFT_SELL_TAX': await safeCall(ecosystem, 'getFee', [KEYS.NFT_SELL_TAX], 0n),
            'RENTAL_TAX': await safeCall(ecosystem, 'getFee', [KEYS.RENTAL_TAX], 0n),
            'NOTARY_SERVICE': await safeCall(ecosystem, 'getFee', [KEYS.NOTARY_SERVICE], 0n)
        };
        
        for (const [name, value] of Object.entries(fees)) {
            const displayValue = name === 'NOTARY_SERVICE' ? `${formatEther(value)} BKC` : `${value} bips`;
            console.log(`      ${name}: ${displayValue}`);
        }
        
        // Descontos de Booster
        console.log("\n   ğŸ Descontos de Booster:");
        const boostLevels = [100, 250, 500, 1000, 2000, 3500, 5000];
        for (const bips of boostLevels) {
            const discount = await safeCall(ecosystem, 'getBoosterDiscount', [bips], 0n);
            console.log(`      ${bips} bips â†’ ${discount} bips desconto`);
        }
        
    } catch (e) {
        results.critical.push(`ğŸ”´ EcosystemManager: Erro - ${e.message.slice(0, 50)}`);
    }
    console.log("");

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 3. MINING MANAGER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    console.log("3ï¸âƒ£  MINING MANAGER");
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    
    try {
        const mining = new ethers.Contract(ADDRESSES.miningManager, ABIS.miningManager, provider);
        
        const [owner, ecosystemAddr, bkcAddr] = await Promise.all([
            safeCall(mining, 'owner', [], ethers.ZeroAddress),
            safeCall(mining, 'ecosystemManager', [], ethers.ZeroAddress),
            safeCall(mining, 'bkcTokenAddress', [], ethers.ZeroAddress)
        ]);
        
        console.log(`   Owner: ${owner}`);
        console.log(`   EcosystemManager: ${ecosystemAddr}`);
        console.log(`   BKCToken: ${bkcAddr}`);
        
        if (ecosystemAddr.toLowerCase() !== ADDRESSES.ecosystemManager.toLowerCase()) {
            results.critical.push("ğŸ”´ MiningManager: EcosystemManager errado!");
        } else {
            results.ok.push("âœ… MiningManager: EcosystemManager correto");
        }
        
        // Miners autorizados
        console.log("\n   ğŸ” Miners Autorizados:");
        const minerKeys = {
            'DELEGATION_FEE': KEYS.DELEGATION_FEE,
            'UNSTAKE_FEE': KEYS.UNSTAKE_FEE,
            'FORCE_UNSTAKE_PENALTY': KEYS.FORCE_UNSTAKE_PENALTY,
            'CLAIM_REWARD_FEE': KEYS.CLAIM_REWARD_FEE,
            'RENTAL_TAX': KEYS.RENTAL_TAX,
            'NOTARY_SERVICE': KEYS.NOTARY_SERVICE
        };
        
        for (const [name, key] of Object.entries(minerKeys)) {
            const addr = await safeCall(mining, 'authorizedMiners', [key], ethers.ZeroAddress);
            const status = addr === ethers.ZeroAddress ? "âŒ NÃƒO AUTORIZADO" : `âœ… ${addr.slice(0, 10)}...`;
            console.log(`      ${name}: ${status}`);
            
            if (addr === ethers.ZeroAddress) {
                results.warnings.push(`âš ï¸ MiningManager: ${name} sem miner autorizado`);
            }
        }
        
        // Teste de mint amount
        const testAmount = ethers.parseEther("100");
        const mintAmount = await safeCall(mining, 'getMintAmount', [testAmount], 0n);
        console.log(`\n   ğŸ“ˆ Teste Mint: 100 BKC fee â†’ ${formatEther(mintAmount)} BKC minted`);
        
    } catch (e) {
        results.critical.push(`ğŸ”´ MiningManager: Erro - ${e.message.slice(0, 50)}`);
    }
    console.log("");

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 4. DELEGATION MANAGER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    console.log("4ï¸âƒ£  DELEGATION MANAGER");
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    
    try {
        const delegation = new ethers.Contract(ADDRESSES.delegationManager, ABIS.delegationManager, provider);
        
        const [owner, ecosystemAddr, totalPStake, accReward] = await Promise.all([
            safeCall(delegation, 'owner', [], ethers.ZeroAddress),
            safeCall(delegation, 'ecosystemManager', [], ethers.ZeroAddress),
            safeCall(delegation, 'totalNetworkPStake', [], 0n),
            safeCall(delegation, 'accRewardPerStake', [], 0n)
        ]);
        
        console.log(`   Owner: ${owner}`);
        console.log(`   EcosystemManager: ${ecosystemAddr}`);
        console.log(`   Total Network pStake: ${formatEther(totalPStake)}`);
        console.log(`   Acc Reward Per Stake: ${accReward}`);
        
        if (ecosystemAddr.toLowerCase() !== ADDRESSES.ecosystemManager.toLowerCase()) {
            results.critical.push("ğŸ”´ DelegationManager: EcosystemManager errado!");
        } else {
            results.ok.push("âœ… DelegationManager: EcosystemManager correto");
        }
        
        // Dados do usuÃ¡rio
        const [userPStake, pendingRewards, delegations] = await Promise.all([
            safeCall(delegation, 'userTotalPStake', [userAddress], 0n),
            safeCall(delegation, 'pendingRewards', [userAddress], 0n),
            safeCall(delegation, 'getDelegationsOf', [userAddress], [])
        ]);
        
        console.log(`\n   ğŸ‘¤ Seus Dados:`);
        console.log(`      pStake: ${formatEther(userPStake)}`);
        console.log(`      Pending Rewards: ${formatEther(pendingRewards)} BKC`);
        console.log(`      DelegaÃ§Ãµes Ativas: ${delegations.length}`);
        
    } catch (e) {
        results.critical.push(`ğŸ”´ DelegationManager: Erro - ${e.message.slice(0, 50)}`);
    }
    console.log("");

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 5. RENTAL MANAGER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    console.log("5ï¸âƒ£  RENTAL MANAGER");
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    
    try {
        const rental = new ethers.Contract(ADDRESSES.rentalManager, ABIS.rentalManager, provider);
        
        const [owner, ecosystemAddr, bkcAddr, nftAddr, listedIds] = await Promise.all([
            safeCall(rental, 'owner', [], ethers.ZeroAddress),
            safeCall(rental, 'ecosystemManager', [], ethers.ZeroAddress),
            safeCall(rental, 'bkcToken', [], ethers.ZeroAddress),
            safeCall(rental, 'nftContract', [], ethers.ZeroAddress),
            safeCall(rental, 'getAllListedTokenIds', [], [])
        ]);
        
        console.log(`   Owner: ${owner}`);
        console.log(`   EcosystemManager: ${ecosystemAddr}`);
        console.log(`   BKCToken: ${bkcAddr}`);
        console.log(`   NFT Contract: ${nftAddr}`);
        console.log(`   Total Listados: ${listedIds.length}`);
        
        if (ecosystemAddr.toLowerCase() !== ADDRESSES.ecosystemManager.toLowerCase()) {
            results.critical.push("ğŸ”´ RentalManager: EcosystemManager errado!");
        } else {
            results.ok.push("âœ… RentalManager: EcosystemManager correto");
        }
        
        if (nftAddr.toLowerCase() !== ADDRESSES.rewardBoosterNFT.toLowerCase()) {
            results.critical.push("ğŸ”´ RentalManager: NFT Contract errado!");
        }
        
    } catch (e) {
        results.critical.push(`ğŸ”´ RentalManager: Erro - ${e.message.slice(0, 50)}`);
    }
    console.log("");

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 6. NFT LIQUIDITY POOL FACTORY
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    console.log("6ï¸âƒ£  NFT LIQUIDITY POOL FACTORY");
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    
    try {
        const factory = new ethers.Contract(ADDRESSES.nftLiquidityPoolFactory, ABIS.nftFactory, provider);
        
        const [owner, ecosystemAddr, implementation, deployedBips] = await Promise.all([
            safeCall(factory, 'owner', [], ethers.ZeroAddress),
            safeCall(factory, 'ecosystemManagerAddress', [], ethers.ZeroAddress),
            safeCall(factory, 'poolImplementation', [], ethers.ZeroAddress),
            safeCall(factory, 'getDeployedBoostBips', [], [])
        ]);
        
        console.log(`   Owner: ${owner}`);
        console.log(`   EcosystemManager: ${ecosystemAddr}`);
        console.log(`   Implementation: ${implementation}`);
        console.log(`   Pools Deployados: ${deployedBips.length}`);
        
        if (ecosystemAddr.toLowerCase() !== ADDRESSES.ecosystemManager.toLowerCase()) {
            results.critical.push("ğŸ”´ NFTFactory: EcosystemManager errado!");
        } else {
            results.ok.push("âœ… NFTFactory: EcosystemManager correto");
        }
        
        // Verifica se pools estÃ£o registrados
        console.log("\n   ğŸŠ Pools Registrados:");
        for (const bips of deployedBips) {
            const poolAddr = await safeCall(factory, 'getPoolAddress', [bips], ethers.ZeroAddress);
            const isPool = await safeCall(factory, 'isPool', [poolAddr], false);
            console.log(`      ${bips} bips: ${poolAddr.slice(0, 10)}... | isPool: ${isPool ? 'âœ…' : 'âŒ'}`);
            
            if (!isPool) {
                results.critical.push(`ğŸ”´ Pool ${bips} bips NÃƒO estÃ¡ registrado como vÃ¡lido!`);
            }
        }
        
    } catch (e) {
        results.critical.push(`ğŸ”´ NFTFactory: Erro - ${e.message.slice(0, 50)}`);
    }
    console.log("");

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 7. NFT LIQUIDITY POOLS (INDIVIDUAL)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    console.log("7ï¸âƒ£  NFT LIQUIDITY POOLS");
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    
    const poolNames = ['diamond', 'platinum', 'gold', 'silver', 'bronze', 'iron', 'crystal'];
    const poolAddresses = [
        ADDRESSES.pool_diamond,
        ADDRESSES.pool_platinum,
        ADDRESSES.pool_gold,
        ADDRESSES.pool_silver,
        ADDRESSES.pool_bronze,
        ADDRESSES.pool_iron,
        ADDRESSES.pool_crystal
    ];
    
    for (let i = 0; i < poolNames.length; i++) {
        const name = poolNames[i].toUpperCase();
        const addr = poolAddresses[i];
        
        try {
            const pool = new ethers.Contract(addr, ABIS.nftPool, provider);
            
            const [boostBips, buyPrice, sellPrice, poolInfo, availableIds] = await Promise.all([
                safeCall(pool, 'boostBips', [], 0n),
                safeCall(pool, 'getBuyPrice', [], 0n),
                safeCall(pool, 'getSellPrice', [], 0n),
                safeCall(pool, 'getPoolInfo', [], [0n, 0n, 0n]),
                safeCall(pool, 'getAvailableTokenIds', [], [])
            ]);
            
            const [tokenBalance, nftCount, k] = poolInfo;
            
            console.log(`\n   ğŸŠ ${name} (${addr.slice(0, 10)}...)`);
            console.log(`      Boost: ${boostBips} bips`);
            console.log(`      Liquidez: ${formatEther(tokenBalance)} BKC`);
            console.log(`      NFTs DisponÃ­veis: ${nftCount.toString()} (IDs: ${availableIds.length})`);
            console.log(`      K (invariante): ${k.toString()}`);
            console.log(`      Buy Price: ${buyPrice === ethers.MaxUint256 ? 'âˆ (VAZIO)' : formatEther(buyPrice) + ' BKC'}`);
            console.log(`      Sell Price: ${formatEther(sellPrice)} BKC`);
            
            // Verifica se pool estÃ¡ vazio
            if (BigInt(nftCount) <= 1n || buyPrice === ethers.MaxUint256) {
                results.warnings.push(`âš ï¸ Pool ${name}: Sem NFTs para compra`);
            }
            
            // Verifica K
            if (BigInt(k) === 0n && BigInt(nftCount) > 0n) {
                results.warnings.push(`âš ï¸ Pool ${name}: K=0 mas tem NFTs (liquidez nÃ£o inicializada?)`);
            }
            
        } catch (e) {
            results.warnings.push(`âš ï¸ Pool ${name}: Erro ao ler - ${e.message.slice(0, 30)}`);
        }
    }
    console.log("");

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 8. REWARD BOOSTER NFT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    console.log("8ï¸âƒ£  REWARD BOOSTER NFT");
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    
    try {
        const booster = new ethers.Contract(ADDRESSES.rewardBoosterNFT, ABIS.rewardBoosterNFT, provider);
        
        const [owner, totalSupply, userBalance] = await Promise.all([
            safeCall(booster, 'owner', [], ethers.ZeroAddress),
            safeCall(booster, 'totalSupply', [], 0n),
            safeCall(booster, 'balanceOf', [userAddress], 0n)
        ]);
        
        console.log(`   Owner: ${owner}`);
        console.log(`   Total Supply: ${totalSupply.toString()} NFTs`);
        console.log(`   Seus NFTs: ${userBalance.toString()}`);
        
    } catch (e) {
        results.warnings.push(`âš ï¸ RewardBoosterNFT: Erro - ${e.message.slice(0, 50)}`);
    }
    console.log("");

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 9. NOTARY
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    console.log("9ï¸âƒ£  DECENTRALIZED NOTARY");
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    
    try {
        const notary = new ethers.Contract(ADDRESSES.decentralizedNotary, ABIS.notary, provider);
        
        const [owner, ecosystemAddr, totalSupply] = await Promise.all([
            safeCall(notary, 'owner', [], ethers.ZeroAddress),
            safeCall(notary, 'ecosystemManager', [], ethers.ZeroAddress),
            safeCall(notary, 'totalSupply', [], 0n)
        ]);
        
        console.log(`   Owner: ${owner}`);
        console.log(`   EcosystemManager: ${ecosystemAddr}`);
        console.log(`   Documents Notarized: ${totalSupply.toString()}`);
        
        if (ecosystemAddr.toLowerCase() !== ADDRESSES.ecosystemManager.toLowerCase()) {
            results.critical.push("ğŸ”´ Notary: EcosystemManager errado!");
        } else {
            results.ok.push("âœ… Notary: EcosystemManager correto");
        }
        
    } catch (e) {
        results.warnings.push(`âš ï¸ Notary: Erro - ${e.message.slice(0, 50)}`);
    }
    console.log("");

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 10. FORTUNE POOL
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    console.log("ğŸ”Ÿ FORTUNE POOL");
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    
    try {
        const fortune = new ethers.Contract(ADDRESSES.fortunePool, ABIS.fortunePool, provider);
        
        const [owner, ecosystemAddr, bkcAddr] = await Promise.all([
            safeCall(fortune, 'owner', [], ethers.ZeroAddress),
            safeCall(fortune, 'ecosystemManager', [], ethers.ZeroAddress),
            safeCall(fortune, 'bkcToken', [], ethers.ZeroAddress)
        ]);
        
        console.log(`   Owner: ${owner}`);
        console.log(`   EcosystemManager: ${ecosystemAddr}`);
        console.log(`   BKCToken: ${bkcAddr}`);
        
        if (ecosystemAddr.toLowerCase() !== ADDRESSES.ecosystemManager.toLowerCase()) {
            results.critical.push("ğŸ”´ FortunePool: EcosystemManager errado!");
        } else {
            results.ok.push("âœ… FortunePool: EcosystemManager correto");
        }
        
    } catch (e) {
        results.warnings.push(`âš ï¸ FortunePool: Erro - ${e.message.slice(0, 50)}`);
    }
    console.log("");

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 11. FAUCET
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    console.log("1ï¸âƒ£1ï¸âƒ£ FAUCET");
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    
    try {
        const faucet = new ethers.Contract(ADDRESSES.faucet, ABIS.faucet, provider);
        
        const [owner, bkcAddr, claimAmount, cooldown] = await Promise.all([
            safeCall(faucet, 'owner', [], ethers.ZeroAddress),
            safeCall(faucet, 'bkcToken', [], ethers.ZeroAddress),
            safeCall(faucet, 'claimAmount', [], 0n),
            safeCall(faucet, 'cooldownTime', [], 0n)
        ]);
        
        console.log(`   Owner: ${owner}`);
        console.log(`   BKCToken: ${bkcAddr}`);
        console.log(`   Claim Amount: ${formatEther(claimAmount)} BKC`);
        console.log(`   Cooldown: ${cooldown.toString()} seconds`);
        
        // Verifica saldo do faucet
        const bkc = new ethers.Contract(ADDRESSES.bkcToken, ["function balanceOf(address) view returns (uint256)"], provider);
        const faucetBalance = await safeCall(bkc, 'balanceOf', [ADDRESSES.faucet], 0n);
        console.log(`   Faucet Balance: ${formatEther(faucetBalance)} BKC`);
        
        if (BigInt(faucetBalance) < BigInt(claimAmount)) {
            results.warnings.push("âš ï¸ Faucet: Saldo insuficiente para claims!");
        }
        
    } catch (e) {
        results.warnings.push(`âš ï¸ Faucet: Erro - ${e.message.slice(0, 50)}`);
    }
    console.log("");

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 12. PUBLIC SALE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    console.log("1ï¸âƒ£2ï¸âƒ£ PUBLIC SALE");
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    
    try {
        const sale = new ethers.Contract(ADDRESSES.publicSale, ABIS.publicSale, provider);
        
        const [owner, ecosystemAddr, nftAddr] = await Promise.all([
            safeCall(sale, 'owner', [], ethers.ZeroAddress),
            safeCall(sale, 'ecosystemManager', [], ethers.ZeroAddress),
            safeCall(sale, 'rewardBoosterNFT', [], ethers.ZeroAddress)
        ]);
        
        console.log(`   Owner: ${owner}`);
        console.log(`   EcosystemManager: ${ecosystemAddr}`);
        console.log(`   NFT Contract: ${nftAddr}`);
        
        if (ecosystemAddr.toLowerCase() !== ADDRESSES.ecosystemManager.toLowerCase()) {
            results.critical.push("ğŸ”´ PublicSale: EcosystemManager errado!");
        } else {
            results.ok.push("âœ… PublicSale: EcosystemManager correto");
        }
        
    } catch (e) {
        results.warnings.push(`âš ï¸ PublicSale: Erro - ${e.message.slice(0, 50)}`);
    }
    console.log("");

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // RESUMO FINAL
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    console.log("                           ğŸ“Š RESUMO DO DIAGNÃ“STICO");
    console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    
    if (results.critical.length > 0) {
        console.log("\nğŸ”´ PROBLEMAS CRÃTICOS (causam reversÃ£o):");
        results.critical.forEach(msg => console.log(`   ${msg}`));
    }
    
    if (results.warnings.length > 0) {
        console.log("\nâš ï¸ AVISOS:");
        results.warnings.forEach(msg => console.log(`   ${msg}`));
    }
    
    if (results.ok.length > 0) {
        console.log("\nâœ… VERIFICAÃ‡Ã•ES OK:");
        results.ok.forEach(msg => console.log(`   ${msg}`));
    }
    
    if (results.info.length > 0) {
        console.log("\nâ„¹ï¸ INFORMAÃ‡Ã•ES:");
        results.info.forEach(msg => console.log(`   ${msg}`));
    }
    
    if (results.critical.length === 0) {
        console.log("\nğŸ‰ NENHUM PROBLEMA CRÃTICO ENCONTRADO!");
        console.log("   Se ainda estiver tendo erros, o problema pode ser:");
        console.log("   â€¢ Saldo insuficiente do usuÃ¡rio");
        console.log("   â€¢ AprovaÃ§Ã£o de tokens nÃ£o feita");
        console.log("   â€¢ Pool especÃ­fico vazio");
        console.log("   â€¢ Problemas de frontend (transactions.js)");
    } else {
        console.log("\nâŒ AÃ‡ÃƒO NECESSÃRIA: Corrija os problemas crÃ­ticos acima!");
    }
    
    console.log("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    
    // Retorna objeto para uso programÃ¡tico
    return {
        addresses: ADDRESSES,
        results: results,
        hasCritical: results.critical.length > 0
    };
    
})();