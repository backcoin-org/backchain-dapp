var ke=Object.defineProperty;var be=(h,e,t)=>e in h?ke(h,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):h[e]=t;var u=(h,e,t)=>be(h,typeof e!="symbol"?e+"":e,t);import{C as le,b as S,U as _,r as K,a as fe,s as J,e as Te,h as ve,c as Ee,A as ge,d as Pe,D as Se,f as _e,g as Ce,i as Re,j as Ie,k as Ae}from"./webIndex-C_Q1EAoE.js";import{B as b,a as L,c as O}from"./bignumber-D7CEMWOK.js";function xe(h){class e extends h.bundles.DataItem{constructor(i,n,s){super((s==null?void 0:s.dataIsRawTransaction)===!0?b.from(i):n.bundles.createData(i,n.tokenConfig.getSigner(),{...s,anchor:(s==null?void 0:s.anchor)??le.randomBytes(32).toString("base64").slice(0,32)}).getRaw());u(this,"Irys");u(this,"signer");this.Irys=n,this.signer=n.tokenConfig.getSigner()}sign(){return super.sign(this.signer)}get size(){return this.getRaw().length}async uploadWithReceipt(i){return(await this.Irys.uploader.uploadTransaction(this,i)).data}async upload(i){return(await this.Irys.uploader.uploadTransaction(this,i)).data}async getPrice(){return this.Irys.utils.getPrice(this.Irys.tokenConfig.name,this.size,{tags:this.tags})}async isValid(){return h.bundles.DataItem.verify(this.getRaw())}}return e}async function ae(h,e,t){const r=h.tokenConfig,{deepHash:i,stringToBuffer:n}=r.irys.bundles,s=await r.getPublicKey(),a=t==="all",o={publicKey:s,currency:h.token,amount:a?"all":new L(t).toString(),nonce:await h.getNonce(),signature:"",sigType:r.getSigner().signatureType},d=await i([n(o.currency),n(o.amount.toString()),n(o.nonce.toString())]);b.isBuffer(o.publicKey)||(o.publicKey=b.from(o.publicKey));const m=await r.sign(d),l=await r.verify(o.publicKey,d,m);o.publicKey=S.encode(o.publicKey),o.signature=S.encode(b.from(m));const p=S.toBuffer(o.publicKey),f=S.toBuffer(o.signature),g=await i([n(o.currency),n(o.amount.toString()),n(o.nonce.toString())]),T=await r.verify(p,g,f),C=await r.ownerToAddress(r.name=="arweave"?S.decode(o.publicKey):S.toBuffer(o.publicKey))===r.address;if(!(l||T||C))throw new Error(`Internal withdrawal validation failed - please report this!
Debug Info:${JSON.stringify(o)}`);const R=await e.post("/account/withdraw",o);if(R.status===202){const v=R.data.tx_id,P=await h.confirmationPoll(v);if(P!==!0)throw new Error(`Unable to confirm withdrawal tx ${v} ${P?P==null?void 0:P.toString():""}`)}else _.checkAndThrow(R,"Withdrawing balance");return R.data}class qe{constructor({url:e,network:t,retryConfig:r,query:i,queryName:n,opts:s}){u(this,"queryVars",{});u(this,"queryFields");u(this,"queryInfo");u(this,"_query");u(this,"gqlURL");u(this,"config");u(this,"resultTracker",{numPages:0,numResults:0,done:!1});if(e=t?this.parseNetwork(t):e,!e)throw new Error("URL or network is required");if(this.gqlURL=new URL(e),this.config={first:!1,userProvided:!1,numPages:1/0,numResults:1e3,retryOpts:{retries:3,maxTimeout:2e3,minTimeout:500,...r}},i===!1)return this;if(!i)throw new Error(`Unable to find query with name ${n}`);if(this.queryInfo={...i},this.queryFields=i.query,!(s!=null&&s.skipVariableSetters))for(const a of Object.keys(i.vars)){if(this[a])throw new Error(`Field setter ${a} has a key conflict - disable with opts.skipVariableSetters OR change the field name and add to query.remapVars`);this[a]=o=>(this.queryVars[a]=o,this)}return this}parseNetwork(e){switch(e){case"mainnet":return new URL("https://arweave.mainnet.irys.xyz/graphql");case"devnet":return new URL("https://arweave.devnet.irys.xyz/graphql");case"arweave":return new URL("https://arweave.net/graphql");default:return}}buildQuery(){var o,d,m,l;if(this.config.userProvided)return this;const e=p=>JSON.stringify(p,(f,g)=>{if(g instanceof Array)return g[0];if(typeof g=="object")return g;if(g!==!1)return""}).replaceAll(":","").replaceAll('"',"").replaceAll(",",`
          `),t=e(this.queryFields),r=e({pageInfo:{[((o=this.queryInfo.paging)==null?void 0:o.hasNextPage)??"hasNextPage"]:void 0}}).slice(1,-1),i=this.queryInfo.enumValues,n={...this.queryInfo.vars,...this.queryVars};this.config.numResults&&((d=this.queryInfo.paging)!=null&&d.limiterName)&&(n[(m=this.queryInfo.paging)==null?void 0:m.limiterName]=Math.max(this.config.numResults,1));for(const[p,f]of Object.entries(this.queryInfo.remapVars??{}))if((n==null?void 0:n[p])!==void 0){if(typeof f=="function"){const g=f(p,n[p],n);if(!g)continue;const[T,C]=g;if(n[T]=C,T===p)continue}else n[f]=n[p];n[p]=void 0}const s=JSON.stringify(n,function(p,f){return f===void 0||f instanceof Array||typeof f=="object"||typeof f=="number"||i!=null&&i.includes(p)?f:`'${f}'`}).replaceAll('"',"").replaceAll("'",'"').slice(1,-1);if(!((l=this==null?void 0:this.queryInfo)!=null&&l.name))throw new Error("Query name is undefined!");const a=this.queryInfo.paging?`query {
      ${this.queryInfo.name}(
        ${s}
      ) {
        edges {
          cursor
          node ${t}
        }
        ${r}
      }
    }`:`query {
    ${this.queryInfo.name}(
      ${s}
    ) 
    ${t}
  }`;return this._query=a,this}async getPage(){var r;if(this.resultTracker.done)return;if(this.buildQuery(),!this._query)throw new Error("Unable to run undefined query");let e;try{e=await K(async i=>{const n=await fe(this.gqlURL.toString(),{method:"post",headers:{"Content-Type":"application/json"},data:{query:this._query}});if(n.data.errors)throw n;return n},this.config.retryOpts)}catch(i){throw new Error(`Error running query
 ${this._query} - ${i.message?i.message+" -":""} (${JSON.stringify(((r=i==null?void 0:i.data)==null?void 0:r.errors.map(n=>n.message))??(i==null?void 0:i.errors)??i)}) `)}if(this.config.userProvided)return this.trimmer([e.data.data].flat(20));const t=e.data.data[this.queryInfo.name];if(this.queryInfo.paging){const i=t.pageInfo[this.queryInfo.paging.hasNextPage]?t.edges.at(-1)[this.queryInfo.paging.cursor]:void 0;return this.queryVars.after=i,this.trimmer(t.edges.map(n=>n.node))}return this.trimmer([t].flat(20))}trimmer(e){var i,n;const t=++this.resultTracker.numPages,r=this.resultTracker.numResults+=e.length;if(e.length===0)return this.resultTracker.done=!0,e;if(t>=((i=this==null?void 0:this.config)==null?void 0:i.numPages)&&(this.resultTracker.done=!0),r>=((n=this==null?void 0:this.config)==null?void 0:n.numResults)){this.resultTracker.done=!0;const s=this.config.numResults-(r-e.length);return e.slice(0,s)}return e}async first(){const e=await this.getPage();return(e==null?void 0:e.at(0))??void 0}maxPages(e){return this.config.numPages=e,this}limit(e){return this.config.numResults=e,this}url(e){return this.gqlURL=new URL(e),this}network(e){const t=this.parseNetwork(e);if(!t)throw new Error(`Invalid network: ${e}`);return this.gqlURL=t,this}async all(){const e=[];do{const t=await this.getPage();if(!t)break;e.push(...t)}while(this.queryVars.after);return e}async*generator(){do{const e=await this.getPage();if(!e)return;for(const t of e)yield t}while(this.queryVars.after)}stream(){return J.Readable.from(this.generator())}query(e){return this._query=e,this.config.userProvided=!0,this}fields(e,t=!1){const r=(i,n,s)=>{for(const a of Object.keys(s)){let o=n[a];Array.isArray(o)&&(o=o[0]);const d=s[a];if(o===void 0)throw new Error(`Illegal field ${i}${a}`);typeof d=="object"&&r(i+a+".",o,d)}};return t||r("",this.queryFields,e),this.queryFields=e,this}variables(e){return this.queryVars={...this.queryVars,...e},this}toQuery(){return this.buildQuery(),this._query}tReturn(){return"tReturn"}tQuery(){return"tQuery"}tVars(){return"tVars"}async then(e,t){return this.all().then(e,t)}async catch(e){return this.then().catch(e)}async finally(e){return this.then().finally(e)}}const $e={id:"",timestamp:0,height:"",previous:""},He={ids:void 0,minHeight:void 0,maxHeight:void 0,pageSize:10,after:void 0,sort:"DESC"},Fe={name:"blocks",query:$e,vars:He,enumValues:["sort"],remapVars:{pageSize:"first",sort:(h,e)=>[h,e==="ASC"?"HEIGHT_ASC":"HEIGHT_DESC"],minHeight:(h,e,t)=>{t.height={...t.height,min:e},t.minHeight=void 0},maxHeight:(h,e,t)=>{t.height={...t.height,max:e},t.maxHeight=void 0}},paging:{hasNextPage:"hasNextPage",cursor:"cursor",limiterName:"pageSize"}},De={id:"",anchor:"",signature:"",recipient:"",owner:{address:"",key:""},fee:{winston:"",ar:""},quantity:{winston:"",ar:""},data:{size:"",type:""},tags:[{name:"",value:""}],block:{id:"",timestamp:0,height:0,previous:""},bundledIn:{id:""}},Be={ids:void 0,from:void 0,to:void 0,tags:void 0,bundledIn:void 0,minHeight:void 0,maxHeight:void 0,pageSize:10,after:void 0,sort:"DESC"},Ue={name:"transactions",query:De,enumValues:["sort"],vars:Be,remapVars:{pageSize:"first",from:"owners",to:"recipients",sort:(h,e)=>[h,e==="ASC"?"HEIGHT_ASC":"HEIGHT_DESC"],minHeight:(h,e,t)=>{t.block={...t.block,min:e},t.minHeight=void 0},maxHeight:(h,e,t)=>{t.block={...t.block,max:e},t.maxHeight=void 0}},paging:{hasNextPage:"hasNextPage",cursor:"cursor",limiterName:"pageSize"}},Ve={amount:"",payingAddress:"",approvedAddress:"",expiresBy:0,timestamp:0,token:""},Ne={tokens:void 0,payingAddresses:void 0,approvedAddresses:void 0,pageSize:100,order:"ASC",after:void 0},Oe={name:"paymentApprovals",query:Ve,enumValues:["order"],vars:Ne,remapVars:{pageSize:"limit"},paging:{hasNextPage:"hasNextPage",cursor:"cursor",limiterName:"pageSize"}},Le={id:"",receipt:{deadlineHeight:0,signature:"",timestamp:0,version:""},tags:[{name:"",value:""}],address:"",token:"",signature:"",timestamp:0},ze={ids:void 0,after:void 0,token:void 0,from:void 0,pageSize:100,sort:"ASC",tags:void 0,fromTimestamp:void 0,toTimestamp:void 0},je={name:"transactions",query:Le,enumValues:["order"],vars:ze,remapVars:{pageSize:"first",sort:"order",from:"owners",fromTimestamp:(h,e,t)=>{const r=new Date(e).getTime();if(isNaN(r))throw new Error("invalid from timestamp");t.timestamp={...t.timestamp,from:r},t.fromTimestamp=void 0},toTimestamp:(h,e,t)=>{const r=new Date(e).getTime();if(isNaN(r))throw new Error("invalid to timestamp");t.timestamp={...t.timestamp,to:r},t.toTimestamp=void 0}},paging:{hasNextPage:"hasNextPage",cursor:"cursor",limiterName:"pageSize"}},Me={"irys:transactions":je,"arweave:transactions":Ue,"arweave:blocks":Fe,"irys:paymentApprovals":Oe};class oe{constructor(e={network:"mainnet"}){u(this,"opts");this.opts=e}search(e,t){const r=(t==null?void 0:t.query)??Me[e];return new qe({...this.opts,query:r,queryName:e})}}class Y{constructor({url:e,bundles:t}){u(this,"api");u(this,"utils");u(this,"uploader");u(this,"funder");u(this,"_address");u(this,"token");u(this,"tokenConfig");u(this,"transactions");u(this,"approval");u(this,"_readyPromise");u(this,"url");u(this,"bundles");u(this,"IrysTransaction");u(this,"debug",!1);switch(e){case"mainnet":e="https://uploader.irys.xyz";break;case"devnet":e="https://devnet.irys.xyz";break}if(!e)throw new Error("Missing required Irys constructor parameter: URL or valid Network");const r=new URL(e);this.url=r,this.bundles=t,this.IrysTransaction=xe(this)}get address(){if(!this._address)throw new Error("Address is undefined, please provide a wallet or run `await irys.ready()`");return this._address}set address(e){this._address=e}get signer(){return this.tokenConfig.getSigner()}async withdrawBalance(e){return ae(this.utils,this.api,e)}async withdrawAll(){return ae(this.utils,this.api,"all")}async getLoadedBalance(){if(!this.address)throw new Error("address is undefined");return this.utils.getBalance(this.address)}async getBalance(e){if(e)return this.utils.getBalance(e);if(!this.address)throw new Error("address is undefined");return this.utils.getBalance(this.address)}async fund(e,t){return this.funder.fund(e,t)}async getPrice(e,t){return this.utils.getPrice(this.token,e,t)}async verifyReceipt(e){return _.verifyReceipt(this.bundles,e)}createTransaction(e,t){return new this.IrysTransaction(e,this,t)}getSigner(){return this.tokenConfig.getSigner()}async upload(e,t){return this.uploader.uploadData(e,t)}async uploadWithReceipt(e,t){return this.uploader.uploadData(e,{...t})}async ready(){return this.tokenConfig.ready&&await this.tokenConfig.ready(),this.address=this.tokenConfig.address,this}get transaction(){const e=this;return{fromRaw(t){return new e.IrysTransaction(t,e,{dataIsRawTransaction:!0})}}}get search(){const e=new oe({url:new URL("/graphql",this.url)});return e.search.bind(e)}query(e){return new oe(e??{url:new URL("graphql",this.url)})}}u(Y,"VERSION","REPLACEMEIRYSVERSION");class Ke{constructor(e){u(this,"_instance");u(this,"cookieMap",new Map);u(this,"config");e&&this.applyConfig(e)}applyConfig(e){this.config=this.mergeDefaults(e),this._instance=void 0}getConfig(){return this.config}async requestInterceptor(e){const t=this.cookieMap.get(new URL(e.baseURL??"").hostname);return t&&(e.headers.cookie=t),e}async responseInterceptor(e){var r;const t=(r=e.headers)==null?void 0:r["set-cookie"];return t&&this.cookieMap.set(e.request.host,t),e}mergeDefaults(e){return{url:e.url,timeout:e.timeout??2e4,logging:e.logging??!1,logger:e.logger??console.log,headers:{...e.headers,"x-irys-js-sdk-version":Y.VERSION},withCredentials:e.withCredentials??!1,retry:{retries:3,maxTimeout:5e3}}}async get(e,t){var r;try{return await this.request(e,{...t,method:"GET"})}catch(i){if((r=i.response)!=null&&r.status)return i.response;throw i}}async post(e,t,r){var i;try{return await this.request(e,{data:t,...r,method:"POST"})}catch(n){if((i=n.response)!=null&&i.status)return n.response;throw n}}get instance(){if(this._instance)return this._instance;const e=fe.create({baseURL:this.config.url.toString(),timeout:this.config.timeout,maxContentLength:1024*1024*512,headers:this.config.headers,withCredentials:this.config.withCredentials});return this.config.withCredentials&&(e.interceptors.request.use(this.requestInterceptor.bind(this)),e.interceptors.response.use(this.responseInterceptor.bind(this))),this.config.logging&&(e.interceptors.request.use(t=>(this.config.logger(`Requesting: ${t.baseURL}/${t.url}`),t)),e.interceptors.response.use(t=>(this.config.logger(`Response: ${t.config.url} - ${t.status}`),t))),this._instance=e}async request(e,t){const r=this.instance,i=(t==null?void 0:t.url)??new URL(e,this.config.url).toString();return r({...t,url:i})}}class Qe{constructor(e){u(this,"irys");this.irys=e}async getApprovals({payingAddresses:e,tokens:t=[this.irys.token],approvedAddresses:r=[this.irys.address]}){return this.queryApproval.payingAddresses(e).tokens(t).approvedAddresses(r)}async getCreatedApprovals({payingAddresses:e=[this.irys.address],tokens:t=[this.irys.token],approvedAddresses:r}){return this.queryApproval.payingAddresses(e).tokens(t).approvedAddresses(r)}get queryApproval(){return this.irys.query().search("irys:paymentApprovals")}async getApproval({payingAddress:e=this.irys.address,token:t=this.irys.token,approvedAddress:r}){const i=await this.irys.api.get("/account/approval",{params:{payingAddress:e,token:t,approvedAddress:r}});return i.status===404?{amount:"0"}:(_.checkAndThrow(i),i.data)}async getApprovedBalanceFrom(e){if(!e)throw new Error("Paying address is required");return await this.getApproval({payingAddress:e,approvedAddress:this.irys.address,token:this.irys.token})}async createApproval({approvedAddress:e,amount:t,expiresInSeconds:r}){const i=[{name:z.APPROVE_PAYMENT,value:e},{name:j.AMOUNT,value:t.toString()}];return r&&i.push({name:j.EXPIRE_SECONDS,value:r.toString()}),await this.irys.upload("",{tags:i})}async revokeApproval({approvedAddress:e}){const t=[{name:z.DELETE_APPROVAL,value:e}];return await this.irys.upload("",{tags:t})}}var z;(function(h){h.APPROVE_PAYMENT="x-irys-approve-payment",h.DELETE_APPROVAL="x-irys-delete-payment-approval"})(z||(z={}));var j;(function(h){h.AMOUNT="x-amount",h.EXPIRE_SECONDS="x-expire-seconds"})(j||(j={}));var M;(function(h){h.PAID_BY="x-irys-paid-by"})(M||(M={}));const Ge=Symbol("not readable"),Je=Symbol("readable"),We=Symbol("ended"),Ye=Symbol("errored"),k={notReadable:Ge,readable:Je,ended:We,errored:Ye};class Xe{constructor(e,{size:t}={}){u(this,"_stream");u(this,"_error");u(this,"_state",k.notReadable);u(this,"_size");u(this,"_rejections",new Set);this._stream=e,this._size=t;const r=["_handleStreamEnd","_handleStreamError"];for(const i of r)Object.defineProperty(this,i,{configurable:!0,writable:!0,value:this[i].bind(this)});e.once("error",this._handleStreamError),e.once("end",this._handleStreamEnd),e.on("readable",()=>{this._state=k.readable})}get closed(){return this._state===k.ended}[Symbol.asyncIterator](){return this}async next(){switch(this._state){case k.notReadable:{let e,t;try{e=this._untilReadable(),t=this._untilEnd(),await Promise.race([e.promise,t.promise])}finally{e!=null&&e.close(),t!=null&&t.close()}return this.next()}case k.ended:return this.close(),{done:!0,value:void 0};case k.errored:throw this.close(),this._error;case k.readable:{const e=this._size?this._stream.read(this._size):this._stream.read();return e!==null?{done:!1,value:e}:(this._state=k.notReadable,await new Promise(t=>setTimeout(r=>r(!0),0,t)),this.next())}}}_untilReadable(){let e;const t=new Promise((i,n)=>{e=()=>{this._state=k.readable,this._rejections.delete(n),i()},this._state,k.readable,this._stream.once("readable",e),this._rejections.add(n)});return{close:()=>{e!=null&&this._stream.removeListener("readable",e)},promise:t}}_untilEnd(){let e;const t=new Promise((i,n)=>{e=()=>{this._state=k.ended,this._rejections.delete(n),i()},this._stream.once("end",e),this._rejections.add(n)});return{close:()=>{e!=null&&this._stream.removeListener("end",e)},promise:t}}return(){return this._state=k.ended,this.next()}throw(e){return this._error=e,this._state=k.errored,this.next()}close(e){this._stream.removeListener("end",this._handleStreamEnd),this._stream.removeListener("error",this._handleStreamError),this._state=k.ended,this._stream.destroy(e)}_handleStreamError(e){this._error=e,this._state=k.errored;for(const t of this._rejections)t(e)}_handleStreamEnd(){this._state=k.ended}get state(){return this._state}}class Ze extends Te.EventEmitter{constructor(t,r){super({captureRejections:!0});u(this,"tokenConfig");u(this,"api");u(this,"uploadID");u(this,"token");u(this,"chunkSize");u(this,"batchSize");u(this,"paused",!1);u(this,"isResume",!1);u(this,"uploadOptions");u(this,"bundles");this.tokenConfig=t,this.bundles=this.tokenConfig.irys.bundles,this.api=r,this.token=this.tokenConfig.name,this.chunkSize=25e6,this.batchSize=5,this.uploadID=""}setResumeData(t){return t&&(this.uploadID=t,this.isResume=!0),this}getResumeData(){return this.uploadID}setChunkSize(t){if(t<1)throw new Error("Invalid chunk size (must be >=1)");return this.chunkSize=t,this}setBatchSize(t){if(t<1)throw new Error("Invalid batch size (must be >=1)");return this.batchSize=t,this}pause(){this.emit("pause"),this.paused=!0}resume(){this.paused=!1,this.emit("resume")}async uploadTransaction(t,r){return this.uploadOptions=r,this.bundles.DataItem.isDataItem(t)?this.runUpload(t.getRaw()):this.runUpload(t)}async uploadData(t,r){return this.uploadOptions=r==null?void 0:r.upload,this.runUpload(t,{...r})}async runUpload(t,r){var ee,te,re;let i=this.uploadID;const n=r===void 0,s={"x-chunking-version":"2"};let a;if(!i)a=await this.api.get(`/chunks/${this.token}/-1/-1`,{headers:s}),_.checkAndThrow(a,"Getting upload token"),this.uploadID=i=a.data.id;else{if(a=await this.api.get(`/chunks/${this.token}/${i}/-1`,{headers:s}),a.status===404)throw new Error("Upload ID not found - your upload has probably expired.");if(_.checkAndThrow(a,"Getting upload info"),this.chunkSize!=+a.data.size)throw new Error(`Chunk size not equal to that of a previous upload (${+a.data.size}).`)}const{max:o,min:d}=a.data;if(this.chunkSize<+d||this.chunkSize>+o)throw new Error(`Chunk size out of allowed range: ${d} - ${o}`);let m=0;const l=(c,y,E)=>new Promise(x=>{K(async G=>{await this.api.post(`/chunks/${this.token}/${i}/${y}`,c,{headers:{"Content-Type":"application/octet-stream",...s},maxBodyLength:1/0,maxContentLength:1/0}).then(I=>{var se;if((I==null?void 0:I.status)>=300){const ie={res:I,id:E,offset:y,size:c.length};if(this.emit("chunkError",ie),(I==null?void 0:I.status)===402){const ne=(se=w==null?void 0:w.headers)==null?void 0:se["retry-after"],we="402 error: "+w.data+(ne?` - retry after ${ne}s`:"");G(new Error(we))}throw ie}this.emit("chunkUpload",{id:E,offset:y,size:c.length,totalUploaded:m+=c.length}),x({o:y,d:I})})})}),p=a.data.chunks??[],f=new J.PassThrough;let g=b.alloc(0),T=!1,C=!0;f.on("end",()=>T=!0),f.on("error",c=>{throw new Error(`Error processing readable: ${c}`)});const R=async c=>{for(;!T;){if(g.length>=c)return y=b.from(g.slice(0,c)),g=g.slice(c),y;var y=f.read(c);if(y===null){await new Promise(E=>setTimeout(x=>x(!0),0,E));continue}if(y.length===c)return y;g=b.concat([g,y])}for(;g.length>=c;)return y=b.from(g.slice(0,c)),g=g.slice(c),y;return C=!1,g};let v,P;if(!n){v=this.bundles.createData("",this.tokenConfig.getSigner(),{...r,anchor:(r==null?void 0:r.anchor)??le.randomBytes(32).toString("base64").slice(0,32)});const c=v.getRaw();P=c.length,f.write(c),m-=c.length}if(b.isBuffer(t))f.write(t),f.end();else if("pipe"in t)t.pipe(f);else throw new Error("Input data is not a buffer or a compatible stream (no .pipe method)");let q=0;const $=new Set;let Q=0,H,A,X;if(!n){A=new J.PassThrough;const c=v.getRaw().length;if(this.chunkSize<P)throw new Error(`Configured chunk size is too small for transaction header! (${this.chunkSize} < ${P})`);H=await R(this.chunkSize),Q++,q+=H.length,A.write(H.slice(c));const y=[this.bundles.stringToBuffer("dataitem"),this.bundles.stringToBuffer("1"),this.bundles.stringToBuffer(v.signatureType.toString()),v.rawOwner,v.rawTarget,v.rawAnchor,v.rawTags,new Xe(A)];X=this.bundles.deepHash(y)}let N=p.pop();for(;C;){if(this.paused&&await new Promise(E=>this.on("resume",()=>E(void 0))),N&&+N[0]-q<=this.chunkSize){const x=N[1],G=await R(x);n||A.write(G),q+=x,N=p.pop(),Q++,m+=x;continue}const c=await R(this.chunkSize);for(n||A.write(c);$.size>=this.batchSize;){const[E]=await Promise.race($);$.delete(E)}const y=(async()=>await l(c,q,++Q))().then(E=>[y,E]);$.add(y),q+=c.length}if(A&&A.end(),await Promise.all($),!n){const c=await X,y=b.from(await this.tokenConfig.getSigner().sign(c));H.set(y,2),await l(H,0,0)}const Z={"Content-Type":"application/octet-stream",...s};(ee=r==null?void 0:r.upload)!=null&&ee.paidBy&&(Z[M.PAID_BY]=r.upload.paidBy);const w=await this.api.post(`/chunks/${this.token}/${i}/-1`,null,{headers:Z,timeout:((te=this.api.config)==null?void 0:te.timeout)??4e4*10});if(w.status===402){const c=(re=w==null?void 0:w.headers)==null?void 0:re["retry-after"],y="402 error: "+w.data+(c?` - retry after ${c}s`:"");throw new Error(y)}if(_.checkAndThrow(w,"Finalising upload",[201]),w.status===201)throw new Error(w.data);return w.data.verify=_.verifyReceipt.bind({},this.bundles,w.data.data),this.emit("done",w),w}get completionPromise(){return new Promise(t=>this.on("done",t))}}class et{constructor(e){u(this,"utils");this.utils=e}async fund(e,t=1){if(e=new L(e),!e.isInteger())throw new Error("must use an integer for funding amount");const r=this.utils.tokenConfig,i=await this.utils.getBundlerAddress(this.utils.token);let n=r.needsFee?await r.getFee(e,i,t):void 0;n&&L.isBigNumber(n)&&r.getFee.length<3&&(n=n.multipliedBy(t).integerValue());const s=await r.createTx(e,i,n),a=await r.sendTx(s.tx);if(s.txId??(s.txId=a),!s.txId)throw new Error("Undefined transaction ID");let o=await this.utils.confirmationPoll(s.txId);if(!await this.submitTransaction(s.txId).catch(m=>{o=m}))throw new Error(`failed to post funding tx - ${s.txId} - keep this id! 
 ${o?` - ${(o==null?void 0:o.message)??o}`:""}`);return{reward:L.isBigNumber(n)?n.toString():JSON.stringify(n),target:i,quantity:e.toString(),id:s.txId}}async submitTransaction(e){return await K(async()=>{const t=await this.utils.api.post(`/account/balance/${this.utils.token}`,{tx_id:e});return _.checkAndThrow(t,`Posting transaction ${e} information to the bundler`,[202]),t},{retries:5,maxTimeout:1e3,minTimeout:100,randomize:!0})}async submitFundTransaction(e){return this.submitTransaction(e)}}class tt{constructor(e){u(this,"irys");this.irys=e}async getById(e){const t=(await this.query({ids:[e],limit:1})).at(0);if(!t)throw new Error(`Unable to locate tx with id ${e}`);return t}async getByOwner(e){const t=(await this.query({owners:[e],limit:1})).at(0);if(!t)throw new Error(`Unable to locate tx with owner ${e}`);return t}async getByTag(e,t){const r=(await this.query({tags:[{name:e,values:[t]}],limit:1})).at(0);if(!r)throw new Error(`Unable to locate tx with tag ${e}:${t}`);return r}async query(e){var n,s;const t=`
    query ($ids: [String!], $after: String, $currency: String, $owners: [String!], $limit: Int, $order: SortOrder, $hasTags: Boolean, $tags: [TagFilter!]) {
      transactions(ids: $ids, after: $after, currency: $currency, owners: $owners, limit: $limit, order: $order, hasTags: $hasTags, tags: $tags) {
        edges {
          cursor
          node {
            address
            currency
            id
            receipt {
              deadlineHeight
              signature
              timestamp
              version
            }
            signature
            tags {
              name
              value
            }
            timestamp
          }
        }
        pageInfo {
          endCursor
          hasNextPage
        }
      }
    }
    `,r=[];let i=null;do{const a=await this.irys.api.post("/graphql",{query:t,variables:{...e,after:i??e.after}},void 0);i=(s=(n=a.data.data.transactions)==null?void 0:n.pageInfo)!=null&&s.hasNextPage?a.data.data.transactions.pageInfo.endCursor:null,r.push(...a.data.data.transactions.edges.map(o=>o.node))}while(i);return r}}var me={},F={},D={},B={};Object.defineProperty(B,"__esModule",{value:!0});B.ValidationError=void 0;class rt extends Error{constructor(e){super(e),Error.captureStackTrace&&typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,this.constructor)}static createFrom(e){return new this(e)}}B.ValidationError=rt;var U={};Object.defineProperty(U,"__esModule",{value:!0});U.PromisePoolError=void 0;class st extends Error{constructor(e,t){super(),this.raw=e,this.item=t,this.name=this.constructor.name,this.message=this.messageFrom(e),Error.captureStackTrace&&typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,this.constructor)}static createFrom(e,t){return new this(e,t)}messageFrom(e){return e instanceof Error||typeof e=="object"?e.message:typeof e=="string"||typeof e=="number"?e.toString():""}}U.PromisePoolError=st;var V={};Object.defineProperty(V,"__esModule",{value:!0});V.StopThePromisePoolError=void 0;class it extends Error{}V.StopThePromisePoolError=it;var ue;function nt(){if(ue)return D;ue=1,Object.defineProperty(D,"__esModule",{value:!0}),D.PromisePoolExecutor=void 0;const h=W(),e=B,t=U,r=V;class i{constructor(){this.meta={tasks:[],items:[],errors:[],results:[],stopped:!1,concurrency:10,shouldResultsCorrespond:!1,processedItems:[],taskTimeout:0},this.handler=s=>s,this.errorHandler=void 0,this.onTaskStartedHandlers=[],this.onTaskFinishedHandlers=[]}useConcurrency(s){if(!this.isValidConcurrency(s))throw e.ValidationError.createFrom(`"concurrency" must be a number, 1 or up. Received "${s}" (${typeof s})`);return this.meta.concurrency=s,this}isValidConcurrency(s){return typeof s=="number"&&s>=1}withTaskTimeout(s){return this.meta.taskTimeout=s,this}concurrency(){return this.meta.concurrency}useCorrespondingResults(s){return this.meta.shouldResultsCorrespond=s,this}shouldUseCorrespondingResults(){return this.meta.shouldResultsCorrespond}taskTimeout(){return this.meta.taskTimeout}for(s){return this.meta.items=s,this}items(){return this.meta.items}itemsCount(){const s=this.items();return Array.isArray(s)?s.length:NaN}tasks(){return this.meta.tasks}activeTaskCount(){return this.activeTasksCount()}activeTasksCount(){return this.tasks().length}processedItems(){return this.meta.processedItems}processedCount(){return this.processedItems().length}processedPercentage(){return this.processedCount()/this.itemsCount()*100}results(){return this.meta.results}errors(){return this.meta.errors}withHandler(s){return this.handler=s,this}hasErrorHandler(){return!!this.errorHandler}handleError(s){return this.errorHandler=s,this}onTaskStarted(s){return this.onTaskStartedHandlers=s,this}onTaskFinished(s){return this.onTaskFinishedHandlers=s,this}hasReachedConcurrencyLimit(){return this.activeTasksCount()>=this.concurrency()}stop(){throw this.markAsStopped(),new r.StopThePromisePoolError}markAsStopped(){return this.meta.stopped=!0,this}isStopped(){return this.meta.stopped}async start(){return await this.validateInputs().prepareResultsArray().process()}validateInputs(){if(typeof this.handler!="function")throw e.ValidationError.createFrom("The first parameter for the .process(fn) method must be a function");const s=this.taskTimeout();if(!(s==null||typeof s=="number"&&s>=0))throw e.ValidationError.createFrom(`"timeout" must be undefined or a number. A number must be 0 or up. Received "${String(s)}" (${typeof s})`);if(!this.areItemsValid())throw e.ValidationError.createFrom(`"items" must be an array, an iterable or an async iterable. Received "${typeof this.items()}"`);if(this.errorHandler&&typeof this.errorHandler!="function")throw e.ValidationError.createFrom(`The error handler must be a function. Received "${typeof this.errorHandler}"`);return this.onTaskStartedHandlers.forEach(a=>{if(a&&typeof a!="function")throw e.ValidationError.createFrom(`The onTaskStarted handler must be a function. Received "${typeof a}"`)}),this.onTaskFinishedHandlers.forEach(a=>{if(a&&typeof a!="function")throw e.ValidationError.createFrom(`The error handler must be a function. Received "${typeof a}"`)}),this}areItemsValid(){const s=this.items();return!!(Array.isArray(s)||typeof s[Symbol.iterator]=="function"||typeof s[Symbol.asyncIterator]=="function")}prepareResultsArray(){const s=this.items();return Array.isArray(s)?this.shouldUseCorrespondingResults()?(this.meta.results=Array(s.length).fill(h.PromisePool.notRun),this):this:this}async process(){let s=0;for await(const a of this.items()){if(this.isStopped())break;this.shouldUseCorrespondingResults()&&(this.results()[s]=h.PromisePool.notRun),this.startProcessing(a,s),s+=1,await this.waitForProcessingSlot()}return await this.drained()}async waitForProcessingSlot(){for(;this.hasReachedConcurrencyLimit();)await this.waitForActiveTaskToFinish()}async waitForActiveTaskToFinish(){await Promise.race(this.tasks())}startProcessing(s,a){const o=this.createTaskFor(s,a).then(d=>{this.save(d,a).removeActive(o)}).catch(async d=>{await this.handleErrorFor(d,s,a),this.removeActive(o)}).finally(()=>{this.processedItems().push(s),this.runOnTaskFinishedHandlers(s)});this.tasks().push(o),this.runOnTaskStartedHandlers(s)}async createTaskFor(s,a){if(this.taskTimeout()===void 0)return this.handler(s,a,this);const[o,d]=this.createTaskTimeout(s);return Promise.race([this.handler(s,a,this),o()]).finally(d)}createTaskTimeout(s){let a;return[async()=>new Promise((m,l)=>{a=setTimeout(()=>{l(new t.PromisePoolError(`Task in promise pool timed out after ${this.taskTimeout()}ms`,s))},this.taskTimeout())}),()=>clearTimeout(a)]}save(s,a){return this.shouldUseCorrespondingResults()?this.results()[a]=s:this.results().push(s),this}removeActive(s){return this.tasks().splice(this.tasks().indexOf(s),1),this}async handleErrorFor(s,a,o){if(this.shouldUseCorrespondingResults()&&(this.results()[o]=h.PromisePool.failed),!this.isStoppingThePoolError(s)){if(this.isValidationError(s))throw this.markAsStopped(),s;this.hasErrorHandler()?await this.runErrorHandlerFor(s,a):this.saveErrorFor(s,a)}}isStoppingThePoolError(s){return s instanceof r.StopThePromisePoolError}isValidationError(s){return s instanceof e.ValidationError}async runErrorHandlerFor(s,a){var o;try{await((o=this.errorHandler)==null?void 0:o.call(this,s,a,this))}catch(d){this.rethrowIfNotStoppingThePool(d)}}runOnTaskStartedHandlers(s){this.onTaskStartedHandlers.forEach(a=>{a(s,this)})}runOnTaskFinishedHandlers(s){this.onTaskFinishedHandlers.forEach(a=>{a(s,this)})}rethrowIfNotStoppingThePool(s){if(!this.isStoppingThePoolError(s))throw s}saveErrorFor(s,a){this.errors().push(t.PromisePoolError.createFrom(s,a))}async drained(){return await this.drainActiveTasks(),{errors:this.errors(),results:this.results()}}async drainActiveTasks(){await Promise.all(this.tasks())}}return D.PromisePoolExecutor=i,D}var he;function W(){if(he)return F;he=1,Object.defineProperty(F,"__esModule",{value:!0}),F.PromisePool=void 0;const h=nt();class e{constructor(r){this.timeout=void 0,this.concurrency=10,this.items=r??[],this.errorHandler=void 0,this.onTaskStartedHandlers=[],this.onTaskFinishedHandlers=[],this.shouldResultsCorrespond=!1}withConcurrency(r){return this.concurrency=r,this}static withConcurrency(r){return new this().withConcurrency(r)}withTaskTimeout(r){return this.timeout=r,this}static withTaskTimeout(r){return new this().withTaskTimeout(r)}for(r){const i=new e(r).withConcurrency(this.concurrency);return typeof this.errorHandler=="function"&&i.handleError(this.errorHandler),typeof this.timeout=="number"?i.withTaskTimeout(this.timeout):i}static for(r){return new this().for(r)}handleError(r){return this.errorHandler=r,this}onTaskStarted(r){return this.onTaskStartedHandlers.push(r),this}onTaskFinished(r){return this.onTaskFinishedHandlers.push(r),this}useCorrespondingResults(){return this.shouldResultsCorrespond=!0,this}async process(r){return new h.PromisePoolExecutor().useConcurrency(this.concurrency).useCorrespondingResults(this.shouldResultsCorrespond).withTaskTimeout(this.timeout).withHandler(r).handleError(this.errorHandler).onTaskStarted(this.onTaskStartedHandlers).onTaskFinished(this.onTaskFinishedHandlers).for(this.items).start()}}return F.PromisePool=e,e.notRun=Symbol("notRun"),e.failed=Symbol("failed"),F}var ye={};Object.defineProperty(ye,"__esModule",{value:!0});var pe={};Object.defineProperty(pe,"__esModule",{value:!0});(function(h){var e=O&&O.__createBinding||(Object.create?function(i,n,s,a){a===void 0&&(a=s);var o=Object.getOwnPropertyDescriptor(n,s);(!o||("get"in o?!n.__esModule:o.writable||o.configurable))&&(o={enumerable:!0,get:function(){return n[s]}}),Object.defineProperty(i,a,o)}:function(i,n,s,a){a===void 0&&(a=s),i[a]=n[s]}),t=O&&O.__exportStar||function(i,n){for(var s in i)s!=="default"&&!Object.prototype.hasOwnProperty.call(n,s)&&e(n,i,s)};Object.defineProperty(h,"__esModule",{value:!0});const r=W();h.default=r.PromisePool,t(ye,h),t(W(),h),t(U,h),t(pe,h),t(V,h),t(B,h)})(me);const de=5e7;class at{constructor(e,t,r,i,n){u(this,"api");u(this,"token");u(this,"tokenConfig");u(this,"utils");u(this,"contentTypeOverride");u(this,"forceUseChunking");u(this,"bundles");u(this,"irysTransaction");this.api=e,this.token=r,this.tokenConfig=i,this.bundles=this.tokenConfig.irys.bundles,this.utils=t,this.irysTransaction=n}async uploadTransaction(e,t){var n;let r;const i=this.bundles.DataItem.isDataItem(e);if(this.forceUseChunking||i&&e.getRaw().length>=de||!i)r=await this.chunkedUploader.uploadTransaction(i?e.getRaw():e,t);else{const{url:s,timeout:a,headers:o}=this.api.getConfig(),d={"Content-Type":"application/octet-stream",...o};if(t!=null&&t.paidBy&&(d[M.PAID_BY]=t.paidBy),r=await this.api.post(new URL(`/tx/${this.token}`,s).toString(),e.getRaw(),{headers:d,timeout:a,maxBodyLength:1/0}),r.status===201)throw new Error(r.data)}switch(r.status){case 402:const s=(n=r==null?void 0:r.headers)==null?void 0:n["retry-after"],a="402 error: "+r.data+(s?` - retry after ${s}s`:"");throw new Error(a);default:if(r.status>=400)throw new Error(`whilst uploading Irys transaction: ${r.status} ${ve(r)}`)}return r.data.verify=async()=>this.utils.verifyReceipt(r.data),r}async uploadData(e,t){if(typeof e=="string"&&(e=b.from(e)),b.isBuffer(e)&&e.length<=de){const r=this.bundles.createData(e,this.tokenConfig.getSigner(),{...t,anchor:(t==null?void 0:t.anchor)??Ee.randomBytes(32).toString("base64").slice(0,32)});return await r.sign(this.tokenConfig.getSigner()),(await this.uploadTransaction(r,{...t==null?void 0:t.upload})).data}return(await this.chunkedUploader.uploadData(e,t)).data}async concurrentUploader(e,t){const r=[],i=t!=null&&t.logFunction?t==null?void 0:t.logFunction:async a=>{},n=(t==null?void 0:t.concurrency)??5,s=await me.PromisePool.for(e).withConcurrency(n>=1?n:5).handleError(async(a,o,d)=>{if(r.push(a),a.message.includes("402 error"))throw d.stop(),a}).process(async(a,o,d)=>{await K(async m=>{try{const l=await this.processItem(a,t==null?void 0:t.itemOptions);return o%n==0&&await i(`Processed ${o} Items`),t!=null&&t.resultProcessor?await t.resultProcessor({item:a,res:l,i:o},d):{item:a,res:l,i:o}}catch(l){throw l!=null&&l.message.includes("402 error")&&m(l),l}},{retries:3,minTimeout:1e3,maxTimeout:1e4})});return{errors:r,results:s.results}}async processItem(e,t){return this.bundles.DataItem.isDataItem(e)?this.uploadTransaction(e,{...t==null?void 0:t.upload}):this.uploadData(e,t)}async generateFolder(e){const{items:t,indexFile:r}=e,i={manifest:"irys/paths",version:"0.1.0",paths:{}};if(r){if(!t.has(r))throw new Error(`Unable to access item: ${r}`);i.index={path:r}}for(const[n,s]of t.entries())i.paths[n]={id:s};return i}get chunkedUploader(){return new Ze(this.tokenConfig,this.api)}set useChunking(e){typeof e=="boolean"&&(this.forceUseChunking=e)}set contentType(e){this.contentTypeOverride=e}async uploadBundle(e,t){const{tx:r,txs:i,throwawayKey:n,throwawayKeyAddress:s}=await this.createBundle(e,t);return{...await this.uploadTransaction(r,t),txs:i,throwawayKey:n,throwawayKeyAddress:s}}async createBundle(e,t){var d;const r=(t==null?void 0:t.throwawayKey)??await this.bundles.getCryptoDriver().generateJWK(),i=new ge(r),n=e.map(m=>this.bundles.DataItem.isDataItem(m)?m:this.bundles.createData(m,i)),s=await this.bundles.bundleAndSignData(n,i),a=this.bundles.createData(s.getRaw(),this.tokenConfig.getSigner(),{...t==null?void 0:t.bundleOpts,tags:[{name:"Bundle-Format",value:"binary"},{name:"Bundle-Version",value:"2.0.0"},...((d=t==null?void 0:t.bundleOpts)==null?void 0:d.tags)??[]]}),o=S(b.from(await this.bundles.getCryptoDriver().hash(S.toBuffer(S(i.publicKey)))));return await a.sign(this.tokenConfig.getSigner()),{tx:a,throwawayKey:r,throwawayKeyAddress:o,txs:n}}}const ot=Object.freeze(Object.defineProperty({__proto__:null,Arweave:Pe,DataItem:Se,bundleAndSignData:_e,createData:Ce,deepHash:Re,getCryptoDriver:Ie,stringToBuffer:Ae},Symbol.toStringTag,{value:"Module"}));class ce extends at{constructor(t){super(t.api,t.utils,t.token,t.tokenConfig,t.IrysTransaction);u(this,"irys");this.irys=t}async uploadFile(t,r){const n=(r!=null&&r.tags?r.tags.some(({name:s})=>s.toLowerCase()==="content-type"):!1)?r==null?void 0:r.tags:[...(r==null?void 0:r.tags)??[],{name:"Content-Type",value:t.type}];return this.uploadData(b.from(await t.arrayBuffer()),{tags:n,...r})}async uploadFolder(t,r){const i=[],n=new Map,s=(r==null?void 0:r.throwawayKey)??await this.irys.bundles.getCryptoDriver().generateJWK(),a=new ge(s);for(const l of t){const p=l.name??l.webkitRelativePath,g=(l.tags?l.tags.some(({name:C})=>C.toLowerCase()==="content-type"):!1)?l.tags:[...l.tags??[],{name:"Content-Type",value:l.type}],T=this.irys.bundles.createData(b.from(await l.arrayBuffer()),a,{tags:g});await T.sign(a),i.push(T),n.set(p,T.id)}const o=await this.generateFolder({items:n,indexFile:r==null?void 0:r.indexFileRelPath}),d=this.irys.bundles.createData(JSON.stringify(o),r!=null&&r.separateManifestTx?this.irys.tokenConfig.getSigner():a,{tags:[{name:"Type",value:"manifest"},{name:"Content-Type",value:"application/x.irys-manifest+json"},...(r==null?void 0:r.manifestTags)??[]]});(r==null?void 0:r.separateManifestTx)===!0?(await d.sign(this.irys.tokenConfig.getSigner()),await this.uploadTransaction(d,{...r})):(await d.sign(a),i.push(d));const m=await this.uploadBundle(i,{...r});return{...m.data,manifestId:d.id,manifest:o,throwawayKey:m.throwawayKey,throwawayKeyAddress:m.throwawayKeyAddress,txs:m.txs}}}class ut extends Y{constructor({url:t,wallet:r,config:i,getTokenConfig:n}){super({url:t,bundles:ot});u(this,"uploadFolder");u(this,"uploadFile");u(this,"getTokenConfig");this.debug=(i==null?void 0:i.debug)??!1,this.api=new Ke({url:this.url,timeout:(i==null?void 0:i.timeout)??1e5,headers:i==null?void 0:i.headers}),this.getTokenConfig=n}async build({wallet:t,config:r}){var i;if(this.tokenConfig=await this.getTokenConfig(this),this.url.host.includes("devnet.irys.xyz")&&!(r!=null&&r.providerUrl||t!=null&&t.rpcUrl||(i=this==null?void 0:this.tokenConfig)!=null&&i.inheritsRPC))throw new Error(`Using ${this.url.host} requires a dev/testnet RPC to be configured! see https://docs.irys.xyz/build/d/networks#connecting-to-devnet`);this.token=this.tokenConfig.name,this.utils=new _(this.api,this.token,this.tokenConfig),this.uploader=new ce(this),this.funder=new et(this.utils),this.uploader=new ce(this),this.transactions=new tt(this),this.approval=new Qe(this),this.address="Please run `await Irys.ready()`",this.uploadFolder=this.uploader.uploadFolder.bind(this.uploader),this.uploadFile=this.uploader.uploadFile.bind(this.uploader)}}class ht{constructor(e){u(this,"preAdapters");u(this,"postAdapters");u(this,"token");u(this,"provider");u(this,"config");u(this,"constructed");this.preAdapters=[],this.postAdapters=[],this.token=e,this.config={url:"mainnet",irysConfig:{},provider:void 0}}withProvider(e){return this.provider=e,this}mainnet(){return this.config.url="mainnet",this}devnet(){return this.config.url="devnet",this}withRpc(e){return this.config.irysConfig.providerUrl=e,this}withTokenOptions(e){return this.config.irysConfig.tokenOpts=e,this}bundlerUrl(e){return this.config.url=new URL(e).toString(),this}network(e){return this.config.url=e,this}withIrysConfig(e){return this.config.irysConfig={...this.config.irysConfig,...e},this}timeout(e){return this.config.irysConfig.timeout=e,this}withAdapter(e){return e.phase!="post"&&this.preAdapters.push(e),e.phase!="pre"&&this.postAdapters.push(e),e.load&&e.load(this),this}async build(){const e=new ut({url:this.config.url,config:this.config.irysConfig,getTokenConfig:async t=>{for(const r of this.preAdapters)await r.adaptTokenPre(this,this.token);if(!this.provider)throw new Error("Missing required provider");this.constructed=new this.token({irys:t,wallet:this.provider,providerUrl:this.config.irysConfig.providerUrl,opts:this.config.irysConfig.tokenOpts});for(const r of this.postAdapters)await r.adaptTokenPost(this,this.constructed);return this.constructed}});return await e.build({wallet:this.provider,config:this.config.irysConfig}),await e.ready(),e}async then(e,t){return this.build().then(e,t)}async catch(e){return this.then().catch(e)}async finally(e){return this.then().finally(e)}}const ft=h=>new ht(h);export{ft as WebUploader,ft as default};
